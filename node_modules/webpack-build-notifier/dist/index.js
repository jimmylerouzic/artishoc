"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @class WebpackBuildNotifierPlugin
 * @extends Object
 * A Webpack plugin that generates OS notifications for build steps using node-notifier.
 */
var path_1 = __importDefault(require("path"));
var process_1 = __importDefault(require("process"));
var os_1 = __importDefault(require("os"));
var node_notifier_1 = __importDefault(require("node-notifier"));
var strip_ansi_1 = __importDefault(require("strip-ansi"));
var child_process_1 = require("child_process");
var DEFAULT_ICON_PATH = path_1.default.resolve(__dirname, 'icons');
var WebpackBuildNotifierPlugin = /** @class */ (function () {
    function WebpackBuildNotifierPlugin(cfg) {
        var _this = this;
        this.appName = undefined;
        this.buildSuccessful = false;
        this.hasRun = false;
        // config options
        this.title = 'Webpack Build';
        this.sound = 'Submarine';
        this.successSound = this.sound;
        this.warningSound = this.sound;
        this.failureSound = this.sound;
        this.compilationSound = this.sound;
        this.suppressSuccess = false;
        this.suppressWarning = false;
        this.suppressCompileStart = true;
        this.activateTerminalOnError = false;
        this.successIcon = path_1.default.join(DEFAULT_ICON_PATH, 'success.png');
        this.warningIcon = path_1.default.join(DEFAULT_ICON_PATH, 'warning.png');
        this.failureIcon = path_1.default.join(DEFAULT_ICON_PATH, 'failure.png');
        this.compileIcon = path_1.default.join(DEFAULT_ICON_PATH, 'compile.png');
        this.onClick = function () { return _this.activateTerminalWindow; };
        this.activateTerminalWindow = function () {
            if (process_1.default.platform === 'darwin') {
                // TODO: is there a way to translate $TERM_PROGRAM into the application name
                // to make this more flexible?
                child_process_1.exec('TERM="$TERM_PROGRAM"; ' +
                    '[[ "$TERM" == "Apple_Terminal" ]] && TERM="Terminal"; ' +
                    '[[ "$TERM" == "vscode" ]] && TERM="Visual Studio Code"; ' +
                    'osascript -e "tell application \\"$TERM\\" to activate"');
            }
            else if (process_1.default.platform === 'win32') {
                // TODO: Windows platform
            }
        };
        this.formatMessage = function (error, filepath) {
            var message = undefined;
            if (_this.messageFormatter) {
                message = _this.messageFormatter(error, filepath);
            }
            else {
                message = (error.message || error.details);
                if (message && error.module && error.module.resource) {
                    message = "" + filepath + os_1.default.EOL + message.replace(error.module.resource, '');
                }
            }
            if (message === undefined) {
                return 'Unknown';
            }
            else if (typeof message === 'string') {
                return message.substr(0, 256); // limit message length to 256 characters, fixes #20
            }
            else {
                throw "Invalid message type '" + typeof message + "'; messageFormatter must return a string.";
            }
        };
        this.onCompilationDone = function (results) {
            var notify = false;
            var title = _this.title + " - ";
            var msg = 'Build successful!';
            var icon = _this.successIcon;
            var sound = _this.successSound;
            if (results.hasErrors()) {
                var error = results.compilation.errors[0];
                var errorFilePath = error.module && error.module.rawRequest ? error.module.rawRequest : '';
                notify = true;
                title += 'Error';
                msg = _this.formatMessage(error, errorFilePath);
                icon = _this.failureIcon;
                sound = _this.failureSound;
                _this.buildSuccessful = false;
            }
            else if (!_this.suppressWarning && results.hasWarnings()) {
                var warning = results.compilation.warnings[0];
                var warningFilePath = warning.module && warning.module.rawRequest ? warning.module.rawRequest : '';
                notify = true;
                title += 'Warning';
                msg = _this.formatMessage(warning, warningFilePath);
                icon = _this.warningIcon;
                sound = _this.warningSound;
                _this.buildSuccessful = false;
            }
            else {
                title += 'Success';
                /* istanbul ignore else */
                if (_this.suppressSuccess === 'always' || (_this.suppressSuccess === 'initial' && !_this.hasRun)) {
                    notify = false;
                }
                else if (_this.suppressSuccess === false || !_this.buildSuccessful) {
                    notify = true; // previous build failed, let's show a notification even if success notifications are suppressed
                }
                _this.buildSuccessful = true;
            }
            /* istanbul ignore else */
            if (notify) {
                node_notifier_1.default.notify(Object.assign(_this.notifyOptions || {}, {
                    title: title,
                    sound: sound,
                    icon: icon,
                    appName: _this.appName,
                    message: strip_ansi_1.default(msg),
                    contentImage: _this.logo,
                    wait: !_this.buildSuccessful
                }));
            }
            /* istanbul ignore else */
            if (_this.activateTerminalOnError && !_this.buildSuccessful) {
                _this.activateTerminalWindow();
            }
            _this.hasRun = true;
        };
        this.onCompilationWatchRun = function (compiler, callback) {
            node_notifier_1.default.notify({
                appName: _this.appName,
                title: _this.title,
                message: 'Compilation started...',
                contentImage: _this.logo,
                icon: _this.compileIcon,
                sound: _this.compilationSound
            });
            callback();
        };
        this.registerSnoreToast = function () {
            // ensure the SnoreToast appId is registered, which is needed for Windows Toast notifications
            // this is necessary in Windows 8 and above, (Windows 10 post build 1709), where all notifications must be generated
            // by a valid application.
            // see: https://github.com/KDE/snoretoast, https://github.com/RoccoC/webpack-build-notifier/issues/20
            /* istanbul ignore else */
            if (process_1.default.platform === 'win32') {
                var versionParts = os_1.default.release().split('.');
                var winVer = +(versionParts[0] + "." + versionParts[1]);
                /* istanbul ignore else */
                if (winVer >= 6.2) {
                    // Windows version >= 8
                    var snoreToast = path_1.default.join(require.resolve('node-notifier'), '../vendor/snoreToast/SnoreToast.exe');
                    try {
                        child_process_1.execFileSync(snoreToast, [
                            '-appID',
                            'Snore.DesktopToasts',
                            '-install',
                            'SnoreToast.lnk',
                            snoreToast,
                            'Snore.DesktopToasts'
                        ]);
                        _this.appName = 'Snore.DesktopToasts';
                    }
                    catch (e) {
                        console.error('An error occurred while attempting to install the SnoreToast AppID!', e);
                    }
                }
            }
        };
        Object.assign(this, cfg);
        this.registerSnoreToast();
        node_notifier_1.default.on('click', this.onClick);
        /* istanbul ignore else */
        if (this.onTimeout) {
            node_notifier_1.default.on('timeout', this.onTimeout);
        }
    }
    WebpackBuildNotifierPlugin.prototype.apply = function (compiler) {
        if (compiler.hooks && compiler.hooks.watchRun && compiler.hooks.done) {
            // for webpack >= 4
            /* istanbul ignore else */
            if (!this.suppressCompileStart) {
                compiler.hooks.watchRun.tapAsync('webpack-build-notifier', this.onCompilationWatchRun);
            }
            compiler.hooks.done.tap('webpack-build-notifier', this.onCompilationDone);
        }
        else {
            // for webpack < 4
            /* istanbul ignore else */
            if (!this.suppressCompileStart) {
                compiler.plugin('watch-run', this.onCompilationWatchRun);
            }
            compiler.plugin('done', this.onCompilationDone);
        }
    };
    return WebpackBuildNotifierPlugin;
}());
exports.default = WebpackBuildNotifierPlugin;
module.exports = WebpackBuildNotifierPlugin;
